// loralink_multi.c
// multi-client LoRa+UART z libsodium i pthread
// gcc loralink_multi.c -o loralink_multi -lsodium -lpthread

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <termios.h>
#include <sys/select.h>
#include <pthread.h>
#include <ctype.h>
#include <sodium.h>

#define NONCE_LEN crypto_secretbox_NONCEBYTES // 24
#define MAC_LEN crypto_secretbox_MACBYTES // 16
#define KEY_LEN crypto_secretbox_KEYBYTES // 32
#define PK_LEN crypto_kx_PUBLICKEYBYTES // 32
#define SK_LEN crypto_kx_SECRETKEYBYTES // 32
#define SESSION_KEY_LEN crypto_kx_SESSIONKEYBYTES // 32

#define MAX_FRAME 240
#define MAX_PLAINTEXT (MAX_FRAME - NONCE_LEN - MAC_LEN)
#define HELLO_MSG "HELLO test123"
#define HELLO_LEN (sizeof(HELLO_MSG)-1)

#define MAX_CLIENTS 10

typedef struct {
int id;
unsigned char rx_key[SESSION_KEY_LEN];
unsigned char tx_key[SESSION_KEY_LEN];
} client_t;

static client_t clients[MAX_CLIENTS];
static int client_count = 0;
static pthread_mutex_t clients_mutex = PTHREAD_MUTEX_INITIALIZER;

// otwiera UART 115200 8N1, NOBLOCK
int open_serial(const char *dev) {
int fd = open(dev, O_RDWR | O_NOCTTY | O_NONBLOCK);
if (fd < 0) { perror("open_serial"); exit(1); }
struct termios tio;
tcgetattr(fd, &tio);
cfmakeraw(&tio);
cfsetispeed(&tio, B115200);
cfsetospeed(&tio, B115200);
tio.c_cflag |= CLOCAL|CREAD;
tio.c_cflag &= ~CRTSCTS;
tcsetattr(fd, TCSANOW, &tio);
return fd;
}

// dokładnie czyta len bajtów
ssize_t read_all(int fd, void *buf, size_t len) {
size_t tot = 0;
while (tot < len) {
ssize_t r = read(fd, (unsigned char*)buf+tot, len-tot);
if (r < 0) {
if (errno==EINTR) continue;
if (errno==EAGAIN||errno==EWOULDBLOCK) { usleep(10000); continue; }
return -1;
}
if (r==0) return 0;
tot += r;
}
return tot;
}

// dokładnie wysyła len bajtów
ssize_t write_all(int fd, const void *buf, size_t len) {
size_t s = 0;
while (s < len) {
ssize_t n = write(fd, (const unsigned char*)buf+s, len-s);
if (n <= 0) {
if (errno==EINTR) continue;
return -1;
}
s += n;
}
return s;
}

// wątek serwera, przyjmuje nowe HELLO i dodaje klienta
void *accept_clients(void *arg) {
int ser = *(int*)arg;
while (1) {
// czekaj na HELLO
unsigned char hb[HELLO_LEN];
if (read_all(ser, hb, HELLO_LEN) != HELLO_LEN) continue;
if (memcmp(hb, HELLO_MSG, HELLO_LEN)) continue;

// przygotuj parę kluczy
unsigned char my_pk[PK_LEN], my_sk[SK_LEN], peer_pk[PK_LEN];
if (crypto_kx_keypair(my_pk, my_sk) != 0) {
fprintf(stderr,"crypto_kx_keypair failed\n"); continue;
}

// zarezerwuj slot
pthread_mutex_lock(&clients_mutex);
if (client_count >= MAX_CLIENTS) {
pthread_mutex_unlock(&clients_mutex);
fprintf(stderr,"Max clients reached\n");
continue;
}
int id = client_count++;
clients[id].id = id;
pthread_mutex_unlock(&clients_mutex);

// wyślij ID + pk serwera
unsigned char idb = (uint8_t)id;
write_all(ser, &idb, 1);
write_all(ser, my_pk, PK_LEN);

// odbierz pk klienta
if (read_all(ser, peer_pk, PK_LEN) != PK_LEN) {
fprintf(stderr,"Reading client PK failed\n"); continue;
}

// wylicz klucze sesji
unsigned char rxk[SESSION_KEY_LEN], txk[SESSION_KEY_LEN];
if (crypto_kx_server_session_keys(rxk, txk, my_pk, my_sk, peer_pk) != 0) {
fprintf(stderr,"crypto_kx_server_session_keys failed\n"); continue;
}

// zapisz
memcpy(clients[id].rx_key, rxk, SESSION_KEY_LEN);
memcpy(clients[id].tx_key, txk, SESSION_KEY_LEN);

printf("Client %d connected and session established.\n", id);
}
return NULL;
}

// klient robi handshake i dostaje swój client_id
void handshake_client(int ser,
unsigned char my_pk[PK_LEN], unsigned char my_sk[SK_LEN],
unsigned char peer_pk[PK_LEN],
unsigned char rx_key[SESSION_KEY_LEN], unsigned char tx_key[SESSION_KEY_LEN],
int *out_id)
{
// generate pair
crypto_kx_keypair(my_pk, my_sk);

// HELLO
write_all(ser, HELLO_MSG, HELLO_LEN);
printf("Sent HELLO to server\n");

// odbierz swój ID
unsigned char idb;
read_all(ser, &idb, 1);
*out_id = idb;
printf("Received client_id=%d\n", *out_id);

// odbierz publiczny klucz serwera
read_all(ser, peer_pk, PK_LEN);
printf("Received server PK\n");

// wyślij pk klienta
write_all(ser, my_pk, PK_LEN);
printf("Sent client PK\n");

// SESJA
crypto_kx_client_session_keys(rx_key, tx_key, my_pk, my_sk, peer_pk);
printf("Session keys computed (client)\n");
}

// wysyła do konkretnego klienta
void send_to_client(int ser, int id, const char *msg, size_t len) {
unsigned char nonce[NONCE_LEN];
randombytes_buf(nonce, NONCE_LEN);
unsigned char ctext[NONCE_LEN + MAC_LEN + MAX_PLAINTEXT];
memcpy(ctext, nonce, NONCE_LEN);
crypto_secretbox_easy(ctext + NONCE_LEN, (unsigned char*)msg, len,
nonce, clients[id].tx_key);
uint16_t flen = NONCE_LEN + len + MAC_LEN;
unsigned char hdr[3] = {
(uint8_t)id,
(uint8_t)(flen>>8), (uint8_t)(flen&0xFF)
};
write_all(ser, hdr, 3);
write_all(ser, ctext, flen);
printf(">> to[%d]: %s\n", id, msg);
}

// wysyła do wszystkich
void send_to_all(int ser, const char *msg, size_t len) {
pthread_mutex_lock(&clients_mutex);
int cnt = client_count;
pthread_mutex_unlock(&clients_mutex);
for (int i = 0; i < cnt; i++) {
send_to_client(ser, i, msg, len);
}
}

// tryb interaktywny serwera
void interactive_loop_server(int ser) {
char line[MAX_PLAINTEXT+32];
printf("Server interactive: /all <msg> lub /<id> <msg>\n");
while (fgets(line, sizeof(line), stdin)) {
size_t L = strlen(line);
if (L && line[L-1]=='\n') line[--L]=0;
if (L==0) continue;
if (strncmp(line,"/all ",5)==0) {
send_to_all(ser, line+5, strlen(line+5));
} else if (line[0]=='/' && isdigit(line[1]) && line[2]==' ') {
int id = line[1]-'0';
send_to_client(ser, id, line+3, strlen(line+3));
} else {
printf("Nie rozpoznano komendy\n");
}
}
}

// tryb interaktywny klienta (odbiera tylko swoje ramki)
void interactive_loop_client(int ser,
unsigned char rx_key[SESSION_KEY_LEN],
unsigned char tx_key[SESSION_KEY_LEN],
int client_id)
{
fd_set rd;
char line[MAX_PLAINTEXT+1];
unsigned char buf[MAX_FRAME];
printf("Client interactive. Twój ID=%d. Wpisz tekst i ENTER.\n", client_id);
printf("loralink> "); fflush(stdout);
while (1) {
FD_ZERO(&rd);
FD_SET(STDIN_FILENO,&rd);
FD_SET(ser,&rd);
int maxfd = ser>STDIN_FILENO?ser:STDIN_FILENO;
if (select(maxfd+1,&rd,NULL,NULL,NULL)<0) { perror("select"); break; }

if (FD_ISSET(STDIN_FILENO,&rd)) {
if (!fgets(line,sizeof(line),stdin)) break;
size_t plen = strlen(line);
if (plen&&line[plen-1]=='\n') line[--plen]=0;
unsigned char nonce[NONCE_LEN];
randombytes_buf(nonce,NONCE_LEN);
unsigned char ctext[NONCE_LEN+MAX_PLAINTEXT+MAC_LEN];
memcpy(ctext,nonce,NONCE_LEN);
crypto_secretbox_easy(
ctext+NONCE_LEN,(unsigned char*)line,plen,
nonce, tx_key
);
uint16_t flen = NONCE_LEN+plen+MAC_LEN;
unsigned char hdr[3] = {
(uint8_t)client_id,
(uint8_t)(flen>>8),(uint8_t)(flen&0xFF)
};
write_all(ser,hdr,3);
write_all(ser,ctext,flen);
printf("loralink> ");
fflush(stdout);
}

if (FD_ISSET(ser,&rd)) {
// read header
unsigned char hdr[3];
if (read_all(ser,hdr,3)!=3) { printf("Ser closed\n"); break; }
int dst = hdr[0];
uint16_t flen = ((uint16_t)hdr[1]<<8)|(uint16_t)hdr[2];
if (flen<NONCE_LEN+MAC_LEN||flen>MAX_FRAME) {
// skip
unsigned char trash[128];
size_t togo=flen;
while (togo) {
size_t c = togo>sizeof(trash)?sizeof(trash):togo;
read_all(ser,trash,c);
togo-=c;
}
continue;
}
read_all(ser,buf,flen);
if (dst != client_id) continue; // nie moje
unsigned char *nonce = buf;
unsigned char *cipher = buf+NONCE_LEN;
size_t clen = flen - NONCE_LEN;
unsigned char plain[MAX_PLAINTEXT+1];
if (crypto_secretbox_open_easy(plain, cipher, clen, nonce, rx_key)!=0) {
fprintf(stderr,"Decrypt failed\n"); continue;
}
size_t plen2 = clen - MAC_LEN;
plain[plen2]=0;
printf("\n[od serwera] %s\nloralink> ", plain);
fflush(stdout);
}
}
}

int main(int argc, char *argv[]){
if (argc!=3 || (argv[1][1]!='s' && argv[1][1]!='c')) {
fprintf(stderr,"Usage: %s -s|-c <serial_dev>\n", argv[0]);
return 1;
}
if (sodium_init()<0) { fprintf(stderr,"sodium_init failed\n"); return 1; }
int ser = open_serial(argv[2]);

if (argv[1][1]=='s') {
printf("*** SERVER MODE ***\n");
pthread_t th;
pthread_create(&th,NULL,accept_clients,&ser);
interactive_loop_server(ser);
// nie czekamy na th, exit
} else {
printf("*** CLIENT MODE ***\n");
unsigned char my_pk[PK_LEN], my_sk[SK_LEN], peer_pk[PK_LEN];
unsigned char rx_key[SESSION_KEY_LEN], tx_key[SESSION_KEY_LEN];
int client_id;
handshake_client(ser,my_pk,my_sk,peer_pk,rx_key,tx_key,&client_id);
printf("Ready to communicate encrypted!\n");
printf("loralink> "); fflush(stdout);
interactive_loop_client(ser,rx_key,tx_key,client_id);
}
close(ser);
return 0;
}